\chapter{Concepts and State of the Art}\label{ch:2}

\epigraph{The problem with object-oriented languages is they've got all this
implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.}{Joe Armstrong}

In this section we will discuss the most important concepts that are going to
be used in this paper.


\section{Fundamental Concepts}

\subsection{Modeling, Metamodeling}\label{ch:2.1.1}


	Object-oriented programming is a paradigm which appeared in the
early '60 \cite{wiki:oop} and is based on the concept of defining object and
relationships between them. With the rapid growth of software system
object-oriented design has become a non-trivial problem even for small systems,
thus the need of tools that can assist us in analyzing our design. The use of
object technologies in detecting problems is called object-oriented analysis.

	Modeling, as defined in the dictionary \cite{dictionary:modeling}, is the
representation, often mathematical, of a process, concept, or operation of a system, 
often implemented by a computer program.  There is no general accepted
definition for this term, but for the purpose of this paper we can see a model
as a simplified version of a reality. As there can be many types of maps for the
same territory depending on the purpose (riding a bike, traveling to cities,
sightseeing) there can also be many types of models for the same system depending from which angle
we want view the system. Figure \ref{fig:CatModel} illustrates the idea.

\begin{figure}
\centering
\scalebox{0.4}{\includegraphics{img/concepts/CatModel.png}}
\caption{The same cat but from different perspectives \cite{figure:CatModel}
\label{fig:CatModel}}
\end{figure}	

	
	In order to be able to work with models software analysis tools need to be able
to understand and represent them, thus the need of a way to describe models. For
this the concept of metamodeling has been introduced. The prefix meta- indicates 
an abstraction of a concept \cite{wiki:meta}. Formally, metamodel is an abstract 
syntax which governs the representation of a class of models. One of the most
common metamodels used in object oriented design (modeling) is UML
\cite{book:UMLDistilled}. One is able to describe it's object oriented system by
simply showing and describing the most important entities, i.e objects, and how
they interact with each other. In  figure \ref{fig:umlMetamodel} we have
representation of the XML metamodel described using UML.

   \begin{figure}
		\centering
		\scalebox{0.7}{\includegraphics{img/concepts/umlMetamodel.png}}
		\caption{XML metamodel\label{fig:umlMetamodel}}
	\end{figure}

	A very common case with tools is that people want them aggregated in one larger
tool. In order to do this we will need to define a way to describe software
analysis tools. As software analysis tools use metamodels for describing models,
it natural to assume that we will need a meta-metamodel in order to describe a
metamodel. Thus a metamodel is also governed by a strict set of rules that form
a meta-metamodel. One can easily see that the definition is recursive and we
could continue with it indefinitely. In time many meta-metamodels have been
implemented in order to solve different problems (e.g Ecore, GME, KM3, \ldots{}
etc). For the purpose of this application we have used a simple meta-metamodel
based on three elements: 
	\begin{itemize}
		\item Entity --- represents a generalization of a package, type, method, 
field.
 
		\item Property --- represents a general metric for an entity
		\item Groups --- represents a tuple of one or more entities that are connected
by a relation (e.g inheritance, composition, generalization, all elements of an
entity, \ldots{} etc)
	\end{itemize}
	
	The figure \ref{fig:metamodel} represents the relationship between model,
meta-model, and so on.
	 

\begin{figure}
\centering
\scalebox{0.5}{\includegraphics{img/concepts/metamodel.png}}
\caption{Models and Metamodels\label{fig:metamodel}}
\end{figure}
		
		
\subsection{Java Metadata}\label{ch:2.1.2}

	
	As mentioned above a model is nothing more or less than a simplified version of
a reality/system. In case of software analysis tools this system is actually a
program. In order to be able to manipulate programs (models) we need specific
language support for this type of programming, also called metaprogramming
\cite{website:metaprogramming}. 

	Many languages have different ways and levels of supporting metaprogramming,
in C++ this is done by using the template system (template metaprogramming), in
Java this is done by using the reflection API provided by the compiler and/or by using the annotation
language feature which allows metadata processing, i.e the ability to add
information to your code so that it can be used later for generating boiler
plate code or by enforcing constraints that can be verified at compile-time or
run-time. \cite{book:ThinkingInJava} 
	
	The syntax for defining an annotation is quite straight forward and resembles
very mucth the definition of an interface. The keyword used is \code{interface}
prefixed with the 'at' (@) sign. Different properties can be defined inside the annotation. If you set a default
value for the property it becomes optional. The type of a property can be 
primitive types, \code{Class<?>}, enum types or String.
	
	E.g:
	
	
	\small
	\begin{lstlisting}[language=Java,numbers=left]
	@Retention(RetentionPolicy.SOURCE)
public @interface CreateWarning {
	String[] warning() default "Something is fishy"; 
}
	\end{lstlisting}
	\normalsize{}
	
	Usage:
	
	
	\small
	\begin{lstlisting}[language=Java,numbers=left]
Set<String> names = new HashSet<>();
....
//this message will be outputted as a warning
@CreateWarning("unsafe cast, must change")
String[] nameArray = (String[])names.toArray();
	\end{lstlisting}
	\normalsize{}
	
	\small
	\begin{lstlisting}[language=Java,numbers=left]
//the default message, will be outputted
@CreateWarning
public boolean equals(Object x) {
...
}
	\end{lstlisting}
	\normalsize{}
	
	Of course, as we love recursion, we have meta-annotations which
allow us to describe important information regarding annotations such as:
	\begin{itemize}
	 	\item what king of elements can the current annotation annotate
	 	\item how to store the information is provides ? (in the source file, in the
class file, just drop it after compilation, \ldots{} etc)
	 	\item if it can be repeated more than one time on the same element
	 	\item if the element is  documented
	\end{itemize}
	An example of such an annotation is provided in the definition of
\code{@CreateWarning}, i.e \code{@Retention}.
	
	The most common annotations that are used in java are:
	\begin{enumerate}
	  \item \textbf{@Override} -- indicates that the current method is an \\
 (re)implementation of method from the base class.
  
	  \item \textbf{@Deprecated} -- usually used in frameworks and indicates that
	  the entity will be removed in feature updates and support for it is no longer
 provided.
 
	  \item \textbf{@SuppressWarnings} -- stop the compiler from adding annoying
 warning.
	\end{enumerate}	

	The most complex part comes when we want to associate some semantics 
to our annotations. This is usually done by defining an 
\textbf{annotation processor}, i.e a compiler plugin which will be invoked when
our annotation(s) have been discovered by the compiler. After each 
annotation processor has finished some extra code might have been generated or
some annotations might have been expanded in other annotations or both, in 
this case the compiler starts processing the code and invoking the annotation
processors again as can be seen in figure \ref{fig:annProc}.
	 In order to define an annotation processor one most create a class that
inherits from \code{javax.annotation.processing.AbstractProcessor}. The
most important function is \code{process(Set<TypeElement> annotations,
RoundEnvironment roundEnv)}, here you write your code for scanning, evaluating 
and processing annotations and generating java files. With RoundEnviroment passed 
as parameter you can query for elements annotated with a certain annotation.
	
\begin{figure}
\centering
\scalebox{0.8}{\includegraphics{img/concepts/javac-flow.png}}
\caption{The compiler process with annotation
processing\cite{figure:javac-flow}\label{fig:annProc}}
\end{figure}
		

\section{Tools: CodePro}\label{ch:2.2}


	
	Software analysis tools are usually used by developers when something went
wrong or when someone wants to validate an idea. The developer will be running
the analysis tool(s) to compute complex metrics and interpreting the abstract numbers 
that the tool outputted and will try, in case of abnormal values, to find the
problem and propose a solution for it. The entire process is a pain kill and
mostly likely comes in the most inappropriate moment. \cite{tools:inCode}.

\begin{figure}[h]
\centering
\scalebox{0.5}{\includegraphics{img/concepts/inCodeOverview.png}}
\caption{inCode overview \cite{tools:inCode} \label{fig:inCodeOverview}}
\end{figure}

	CodePro, or by its comercial name INCODE \cite{site:inCode}, is an eclipse
plugin which plans to solve this shortcomings of analysis tools by providing
continuous analysis of the code, marking problems solved and detecting new ones,
also providing arguments and tips on why was the problem detected, what causes
it and how it can be solved. In the figures \ref{fig:inCodeTips} and
\ref{fig:inCodeOverview} you can see examples of the features mentioned above.

\begin{figure}
\centering
\scalebox{0.4}{\includegraphics{img/concepts/inCodeTips.png}}
\caption{inCode tips \cite{tools:inCode} \label{fig:inCodeTips}}
\end{figure}


	From an architectural point of view CodePro defines its own meta-metamodel 
,very similar to the one presented in \ref{ch:2.1.1}, but more complex. The
metamodel which is used is the one provided by Eclipse JDT library, wrapped to fit the
meta-metamodel defined. In \ref{fig:codeProUML} you can see an overview of the
general architecture. From analyzing the diagram we can spot some architectural 
problems related to type safety such as:
	\begin{itemize}
	  \item using strings in order to identify different metrics, types, filters 
 \ldots{} etc.  What will happen when someone changes the name of the entity ? 
 What if we write Class instead of class ? \\
\code{aSystem.getGroup("class group").applyFilter("model class");} 
	 
	  \item property computers accept abstract entities instead of specific 
elements for which the computers are defined. The semantic definition is not 
preserved. If we use the Cyclomatic Complexity metric on a class or package  
instead of a method ? What is the expected return type ? \\
\code{public ResultEntity compute(AbstractEntityInterface anEntity)}

	\end{itemize}
	The tool that I have created is aimed at solving this shortcoming by providing
a way in which you can define a metamodel and it will generate, based on the
provided metadata, a model, everything done in a type safe manner.

\begin{figure}
\centering
\scalebox{0.4}{\includegraphics{img/concepts/codeProUML.png}}
\caption{CodePro meta-metamodel and meta-model overview}
\label{fig:codeProUML}
\end{figure}


